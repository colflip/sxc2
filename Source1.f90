MODULE SHARE_PRECISION2
IMPLICIT NONE
INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(6)
INTEGER, PARAMETER :: DBL = 8
INTEGER, PARAMETER :: DBL2 = SELECTED_REAL_KIND(28)
END MODULE SHARE_PRECISION2

MODULE DB_DATA
IMPLICIT NONE
!REAL*8,PARAMETER,DIMENSION(:)::DIP(16)=(/0.0,30.0,45.0,50.0,60.0,65.0,70.0,75.0,83.0,84.0,85.0,86.0,87.0,88.0,89.0,90.0/)
REAL*8,PARAMETER,DIMENSION(:)::DIP(20)=(/0.0,30.0,45.0,50.0,60.0,65.0,70.0,75.0,78.0,80.0,81.0,82.0,83.0,84.0,85.0,86.0,87.0,88.0,89.0,90.0/)
REAL*8,PARAMETER,DIMENSION(:)::RS(45)=(/0.5,1.0,1.5,2.0,3.0,4.0,5.00,6.0,7.0,8.0,9.0,10.00,12.0,14.0,16.0,18.0,20.00,22.0,24.0,26.0,28.0,30.0, &
& 35.0,40.0,45.0,50.00,60.0,70.0,80.0,90.0,100.00,120.0,140.0,160.0,180.0,200.00,220.0,240.0,260.0,280.0,300.0,350.0,400.0,450.0,500.00/)
REAL*8,PARAMETER,DIMENSION(:)::RT(50)=(/0.5,1.0,1.5,2.0,3.0,4.0,5.00,6.0,7.0,8.0,9.0,10.00,12.0,14.0,16.0,18.0,20.00,22.0,24.0,26.0,28.0,30.0, &
& 35.0,40.0,45.0,50.00,60.0,70.0,80.0,90.0,100.00,120.0,140.0,160.0,180.0,200.00,220.0,240.0,260.0,280.0,300.0,350.0,400.0,450.0,500.00, &
& 600.0, 800.0, 900.0, 1000.0, 2000.0/)
REAL*8 DTB(61) 
REAL*8 DATABASE(20,45,50,61,5)  !存储数据库
END

SUBROUTINE GET_DB(FILENAME,LEN1)
USE DB_DATA
IMPLICIT NONE
INTEGER LEN1
CHARACTER(LEN=LEN1),INTENT(IN) :: FILENAME
INTEGER II,JJ,KK,MM,NN
REAL*8 TEMP
!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
CHARACTER*10 DATE,TIME
INTEGER IALLOC

!读入数据库
OPEN(3,FILE=FILENAME(1:LEN1),STATUS='UNKNOWN')
DO II=1,20
DO JJ=1,45
DO KK=1,50
DO MM=1,61
READ(3,*)(DATABASE(II,JJ,KK,MM,NN),NN=1,5)
ENDDO
ENDDO
ENDDO
ENDDO
CLOSE(3)
DO II=1,61
DTB(II)=(II-1)*0.1
ENDDO

!!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!!!!正式版注释掉这一段代码 2处
!CALL DATE_AND_TIME(DATE,TIME)
!READ(DATE,"(I4)")IALLOC
!IF(IALLOC.GT.2025)THEN
!DTB=0.0
!DATABASE=0.1
!ENDIF
!!!!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

END





FUNCTION MAX_RA(RA)
IMPLICIT NONE
INTEGER,PARAMETER::N=4
REAL*8 RA(4),MAX_RA
INTEGER I
MAX_RA=RA(1)
DO I=1,4
IF(RA(I).GE.0.2.AND.RA(I).LE.2000.0)THEN
IF(MAX_RA.LT.RA(I))MAX_RA=RA(I)
ENDIF
ENDDO
END
FUNCTION MIN_RA(RA)
IMPLICIT NONE
INTEGER,PARAMETER::N=4
REAL*8 RA(N),MIN_RA
INTEGER I
MIN_RA=RA(1)
DO I=1,4
IF(RA(I).GE.0.2.AND.RA(I).LE.2000.0)THEN
IF(MIN_RA.GT.RA(I))MIN_RA=RA(I)
ENDIF
ENDDO
END

SUBROUTINE AziTrakFM2(DIPI,RSI,RTI,DTBI,RAD)
USE DB_DATA
IMPLICIT NONE
REAL*8 DIPI,RSI,RTI,DTBI
REAL*8 RA(5)
REAL*8 RAS(16,5),RAD(5)
INTEGER IU,ID,JU,JD,KU,KD,MU,MD,NU,ND
REAL*8 TEMP1,TEMP2,TEMP3,TEMP4,TEMP5
INTEGER II,JJ,KK,MM,NN
INTEGER I,J
DTBI=ABS(DTBI)
DIPI=ABS(DIPI)
IF(DIPI.GT.90.0)DIPI=180.0-DIPI
!倾角数据库定位
IF(ABS(DIPI).LE.0.0)THEN
IU=1
ID=2
TEMP1=(DIPI-DIP(1))/(DIP(2)-DIP(1))
ELSEIF(ABS(DIPI).GE.89.99)THEN
IU=19
ID=20
TEMP1=(DIPI-DIP(19))/(DIP(20)-DIP(19))
ELSE
DO I=1,19
IF(DIPI.GE.DIP(I).AND.DIPI.LT.DIP(I+1))THEN
IU=I
ID=I+1
TEMP1=(DIPI-DIP(I))/(DIP(I+1)-DIP(I))
EXIT
ENDIF
ENDDO
ENDIF
!围岩数据库定位
IF(RSI.LE.RS(1))THEN
JU=1
JD=2
TEMP2=(RSI-RS(1))/(RS(2)-RS(1))
ELSEIF(RSI.GE.RS(45))THEN
JU=44
JD=45
TEMP2=(RSI-RS(44))/(RS(45)-RS(44))
ELSE
DO I=1,44
IF(RSI.GE.RS(I).AND.RSI.LT.RS(I+1))THEN
JU=I
JD=I+1
TEMP2=(RSI-RS(I))/(RS(I+1)-RS(I))
EXIT
ENDIF
ENDDO
ENDIF
!目的层电阻率数据库定位
IF(RTI.LE.RT(1))THEN
KU=1
KD=2
TEMP3=(RTI-RT(1))/(RT(2)-RT(1))
ELSEIF(RTI.GE.RT(50))THEN
KU=49
KD=50
TEMP3=(RTI-RT(49))/(RT(50)-RT(49))
ELSE
DO I=1,49
IF(RTI.GE.RT(I).AND.RTI.LT.RT(I+1))THEN
KU=I
KD=I+1
TEMP3=(RTI-RT(I))/(RT(I+1)-RT(I))
EXIT
ENDIF
ENDDO
ENDIF
!边界距离数据库定位
IF(DTBI.LE.DTB(1))THEN
MU=1
MD=2
TEMP4=(DTBI-DTB(1))/(DTB(2)-DTB(1))
ELSEIF(DTBI.GE.DTB(61))THEN
MU=60
MD=61
TEMP4=(DTBI-DTB(60))/(DTB(61)-DTB(60))
ELSE
DO I=1,60
IF(DTBI.GE.DTB(I).AND.DTBI.LT.DTB(I+1))THEN
MU=I
MD=I+1
TEMP4=(DTBI-DTB(I))/(DTB(I+1)-DTB(I))
EXIT
ENDIF
ENDDO
ENDIF
NN=0
DO II=IU,ID
DO JJ=JU,JD
DO KK=KU,KD
DO MM=MU,MD
NN=NN+1
RAS(NN,1:5)=DATABASE(II,JJ,KK,MM,1:5)
ENDDO
ENDDO
ENDDO
ENDDO
!线性差值
DO J=1,5
DO I=1,8
RAS(I,J)=(1.0-TEMP1)*RAS(I,J)+TEMP1*RAS(I+8,J)
ENDDO
ENDDO
DO J=1,5
DO I=1,4
RAS(I,J)=(1.0-TEMP2)*RAS(I,J)+TEMP2*RAS(I+4,J)
ENDDO
ENDDO
DO J=1,5
DO I=1,2
RAS(I,J)=(1.0-TEMP3)*RAS(I,J)+TEMP3*RAS(I+2,J)
ENDDO
ENDDO
DO J=1,5
DO I=1,1
RAS(I,J)=(1.0-TEMP4)*RAS(I,J)+TEMP4*RAS(I+1,J)
ENDDO
ENDDO
RA(1:5)=RAS(1,1:5)

RA(5)=RA(5)*235.0*log10(max((RSI+RTI)/5.0,1.5)) !*MAX(RA(3)/2.0,1.0)
RAD=RA
END

SUBROUTINE SORT_DTB(DTBM,DTBU,DTBD)
IMPLICIT NONE
INTEGER,PARAMETER::M=8
REAL*8 DTBM(M),DTBU,DTBD
REAL*8 TEMP,FAR_U,FAR_D
INTEGER I,J,K
DTBU=0.0
DTBD=0.0
J=0
K=0
DO I=1,M
IF(DTBM(I).GE.0)THEN
DTBD=DTBD+DTBM(I)
J=J+1
ENDIF
IF(DTBM(I).LT.0)THEN
DTBU=DTBU+DTBM(I)
K=K+1
ENDIF
ENDDO
IF(J.GE.1)THEN
DTBD=DTBD/(J)
ELSE
DTBD=5.0
ENDIF
IF(K.GE.1)THEN
DTBU=DTBU/K
ELSE
DTBU=-5.0
ENDIF

DO I=1,M
DO J=I,M
IF(DTBM(J).LT.DTBM(I))THEN
TEMP=DTBM(I)
DTBM(I)=DTBM(J)
DTBM(J)=TEMP
ENDIF
ENDDO
ENDDO
DTBM(1:4)=DTBM(1)
DTBM(5:8)=DTBM(8)*2.0
END

SUBROUTINE GET_RT(APPARENT_RT,RES_RT,M)
IMPLICIT NONE
INTEGER M
REAL*8 APPARENT_RT(M),RES_RT,RB(M)
INTEGER I,J
REAL*8 MAX_RA,MIN_RA,A,B
RB=APPARENT_RT
RES_RT=MAX(APPARENT_RT(1),APPARENT_RT(1))+abs(APPARENT_RT(1)-APPARENT_RT(3))*1.73
IF(RES_RT.GE.300.0.OR.RES_RT.GE.5.0*MIN_RA(APPARENT_RT))THEN
RES_RT=MIN(5.0*MIN_RA(APPARENT_RT),300.0)+(RES_RT-MIN(5.0*MIN_RA(APPARENT_RT),300.0))/5000.0
ENDIF
END

SUBROUTINE GET_RS(APPARENT_RT,RES_RS,M)
IMPLICIT NONE
INTEGER M
REAL*8 APPARENT_RT(M),RES_RS,RB(M)
INTEGER I,J
REAL*8 MAX_RA,MIN_RA,A,B
REAL*8 RES_RT
RB=APPARENT_RT
DO I=1,M
IF(APPARENT_RT(I).LE.0.2)THEN
APPARENT_RT(I)=MAX(MAX_RA(APPARENT_RT),0.2)
ENDIF
ENDDO

CALL GET_RT(APPARENT_RT,RES_RT,M)
RES_RS=(MIN_RA(APPARENT_RT)*0.1+RES_RT*0.1)/2.0

!RES_RS=MIN_RA(APPARENT_RT)-ABS(APPARENT_RT(1)-APPARENT_RT(3))*5.2
!RES_RS=MIN_RA(APPARENT_RT)*0.1
!IF(RES_RS.LE.MIN_RA(APPARENT_RT)*0.1)THEN
!RES_RS=MIN_RA(APPARENT_RT)*0.1
!ENDIF
END



SUBROUTINE INV_RT_DTB(APPARENT_RT,GEO_SIGNAL,INITAL,RES_DIP,RES_RS,RES_RT,RES_DTB,RES_DTBM,FLG_YS,RATIO_UP,RATIO_DW)
USE DB_DATA
IMPLICIT NONE
INTEGER,PARAMETER::M=4,N=2 !电阻率曲线条数、地质信号曲线条数
REAL*8 APPARENT_RT(4)
REAL*8 GEO_SIGNAL(2)
REAL*8 INITAL(6)
REAL*8 RES_RT,RES_RS,RES_DIP,RES_DTB,RES_DTBM !输出

REAL*8 DTBU,DTBD,DTBC(8),DTBM(8)
REAL*8 RA(5)
!RS\RT\DTB\DIP
INTEGER I,J,K,L,MM,NN,II
REAL*8 RS1,RS2,RT1,RT2,DTB1,DTB2,RES_INV(4)
REAL*8 TEMP1,TEMP(12),TEMP0,GET_DTB_I,GET_DTB_R,AVG,GET_DTB_I2
REAL*8 RSU,RSD,MIN_RA
INTEGER FLG_YS(6)
REAL*8 RATIO_UP(6),RATIO_DW(6)
REAL*8 UP_YS(6),DW_YU(6)
REAL*8 DIP1,DIP2,D2BU1,D2BU2,D2BD1,D2BD2,RSU1,RSU2,RTH1,RTH2,RSD1,RSD2
REAL*8 DIP0,RS0,RT0,D2B0


!数据预处理
DTBU=-6.0
DTBD=6.0
CALL GET_RT(APPARENT_RT,RES_RT,M)
CALL GET_RS(APPARENT_RT,RES_RS,M)


!约束条件 
!相对倾角约束
IF(FLG_YS(1).EQ.1)THEN
!绝对约束
UP_YS(1)=RATIO_UP(1)
DW_YU(1)=RATIO_DW(1)
DIP1=UP_YS(1)
DIP2=DW_YU(1)
ELSEIF(FLG_YS(1).EQ.2)THEN
!相对约束-初始模型约束
UP_YS(1)=INITAL(1)-RATIO_UP(1)
DW_YU(1)=INITAL(1)+RATIO_DW(1)
DIP1=UP_YS(1)
DIP2=DW_YU(1)
ELSE
!无约束
DIP1=max(INITAL(1)-3.0,30.0)
DIP2=min(INITAL(1)+3.0,90.0)
ENDIF

!上边界距离约束
IF(FLG_YS(2).EQ.1)THEN
!绝对约束
UP_YS(2)=RATIO_UP(2)
DW_YU(2)=RATIO_DW(2)
D2BU1=UP_YS(2)
D2BU2=DW_YU(2)
ELSEIF(FLG_YS(2).EQ.2)THEN
UP_YS(2)=INITAL(2)+RATIO_UP(2)
DW_YU(2)=INITAL(2)+RATIO_DW(2)
D2BU1=UP_YS(2)
D2BU2=DW_YU(2)
ELSE
D2BU1=0.0
D2BU2=6.0
ENDIF

!下边界距离约束
IF(FLG_YS(3).EQ.1)THEN
!绝对约束
UP_YS(3)=RATIO_UP(3)
DW_YU(3)=RATIO_DW(3)
D2BD1=UP_YS(3)
D2BD2=DW_YU(3)
ELSEIF(FLG_YS(3).EQ.2)THEN
!相对值约束
UP_YS(3)=INITAL(3)-RATIO_UP(3)
DW_YU(3)=INITAL(3)+RATIO_DW(3)
D2BD1=UP_YS(3)
D2BD2=DW_YU(3)
ELSE
D2BD1=0.0
D2BD2=6.0
ENDIF

!目的层电阻率约束
IF(FLG_YS(5).EQ.1)THEN
!绝对值约束
UP_YS(5)=RATIO_UP(5)
DW_YU(5)=RATIO_DW(5)
RTH1=UP_YS(5)
RTH2=DW_YU(5)
ELSEIF(FLG_YS(5).EQ.2)THEN
!相对值约束
UP_YS(5)=INITAL(5)-RATIO_UP(5)
DW_YU(5)=INITAL(5)+RATIO_DW(5)
RTH1=max(UP_YS(5),0.5)
RTH2=min(DW_YU(5),2000.0)
ELSE
RTH1=RES_RT*1.0
RTH2=RES_RT*1.0
ENDIF

!上围岩电阻率约束
IF(FLG_YS(4).EQ.1)THEN
!绝对值约束
UP_YS(4)=RATIO_UP(4)
DW_YU(4)=RATIO_DW(4)
RSU1=UP_YS(4)
RSU2=DW_YU(4)
ELSEIF(FLG_YS(4).EQ.1)THEN
!相对值约束
UP_YS(4)=INITAL(4)-RATIO_UP(4)
DW_YU(4)=INITAL(4)+RATIO_DW(4)
RSU1=max(UP_YS(4),0.5)
RSU2=min(DW_YU(4),500.0)
ELSE
RSU1=RES_RS
RSU2=RES_RS
ENDIF
!下围岩电阻率约束
IF(FLG_YS(6).EQ.1)THEN
!绝对值约束
UP_YS(6)=INITAL(6) 
DW_YU(6)=INITAL(6) 
RSD1=UP_YS(6)
RSD2=DW_YU(6)
ELSEIF(FLG_YS(6).EQ.2)THEN
!相对值约束
UP_YS(6)=INITAL(6)-RATIO_UP(6)
DW_YU(6)=INITAL(6)+RATIO_DW(6)
RSD1=max(UP_YS(6),0.5)
RSD2=min(DW_YU(6),500.0)
ELSE
RSU1=RES_RS
RSU2=RES_RS
ENDIF

!查库计算围岩电阻率-目的层电阻率-边界距离
TEMP1=1.0E+12
DO I=1,8 !13  ! 倾角循环
DIP0=DIP1+(DIP2-DIP1)/7.0*(I-1)
DO J=1,1  ! 围岩循环
if(GEO_SIGNAL(2).ge.90.0.and.GEO_SIGNAL(2).le.270.0)then
RS0=RSd1+(RSd2-RSd1)/19.0*(J-1)
else
RS0=RSU1+(RSU2-RSU1)/19.0*(J-1)
endif
DO K=1,1 !地层电阻率循环
RT0=RTH1+(RTH2-RTH1)/19.0*(K-1)
DO L=1,51 !边界距离循环
D2B0=D2BU1+(D2BU2-D2BU1)/50.0*(L-1)
CALL AziTrakFM(DIP0,RS0,RT0,D2B0,RA)
TEMP0=0.0
!DO II=1,2
!IF(APPARENT_RT(2*II-1).GE.0.2.AND.APPARENT_RT(2*II-1).LE.1990.0)THEN
!TEMP0=TEMP0+(RA(2*II-1)-APPARENT_RT(2*II-1))*(RA(2*II-1)-APPARENT_RT(2*II-1))
!ENDIF
!ENDDO
TEMP0=TEMP0+(abs(RA(5))-abs(GEO_SIGNAL(1)))**2.0

IF(TEMP0.LT.TEMP1)THEN
RES_INV(1)=DIP0
RES_INV(2)=RS0
RES_INV(3)=RT0
RES_INV(4)=D2B0
TEMP1=TEMP0
ENDIF
ENDDO
ENDDO
ENDDO
ENDDO
RES_DIP=RES_INV(1)
RES_RS=RES_INV(2)
RES_RT=RES_INV(3)
RES_DTB=RES_INV(4)

!围岩电阻率校正
IF(TEMP1.GE.1.0)THEN
DO J=1,31
IF(RES_RT.GE.RES_RS)THEN
RS0=0.2*RES_RS+(RES_RS)/30.0*(J-1)*0.8
ELSE
RS0=1.0*RES_RS+(RES_RS)/30.0*(J-1)*5.0
ENDIF
DO K=1,51
IF(RES_RT.GE.RES_RS)THEN
RT0=1.0*RES_RT+(RES_RT)/50.0*(J-1)*5.0
ELSE
RT0=0.2*RES_RT+(RES_RT)/50.0*(J-1)*0.8
ENDIF
CALL AziTrakFM(RES_DIP,RS0,RT0,RES_DTB,RA)
TEMP0=0.0
TEMP0=TEMP0+(abs(RA(5))-abs(GEO_SIGNAL(1)))**2.0
IF(TEMP0.LT.TEMP1)THEN
RES_INV(2)=RS0
TEMP1=TEMP0
ENDIF
ENDDO
ENDDO
ENDIF
RES_RS=RES_INV(2)


DTBM(1)=GET_DTB_I2(RA(1),1,GEO_SIGNAL(1),1,RES_RT,RES_DIP,RES_RS)
DTBM(2)=GET_DTB_I2(RA(2),2,GEO_SIGNAL(1),1,RES_RT,RES_DIP,RES_RS)
DTBM(3)=GET_DTB_I2(RA(3),3,GEO_SIGNAL(1),1,RES_RT,RES_DIP,RES_RS)
DTBM(4)=GET_DTB_I2(RA(4),4,GEO_SIGNAL(1),1,RES_RT,RES_DIP,RES_RS)
DTBM(5)=GET_DTB_R(RA(1),1,RA(2),2,RES_RT,RES_DIP,RES_RS)
DTBM(6)=GET_DTB_R(RA(1),1,RA(3),3,RES_RT,RES_DIP,RES_RS)
DTBM(7)=GET_DTB_R(RA(1),1,RA(4),4,RES_RT,RES_DIP,RES_RS)
DTBM(8)=GET_DTB_R(RA(2),2,RA(5),3,RES_RT,RES_DIP,RES_RS)
RES_DTBM=SQRT(MIN_RA(APPARENT_RT)-EXP(-1.0/MIN_RA(APPARENT_RT)))/10.0+2.3
DO I=1,8
IF(DTBM(I).GT.RES_DTBM)THEN
DTBM(I)=RES_DTBM+(DTBM(I)-RES_DTBM)/10.0
ENDIF
ENDDO
DO I=1,8
IF(RES_DTBM.LE.DTBM(I))THEN
RES_DTBM=ABS(DTBM(I))
ENDIF
ENDDO

END

FUNCTION GET_DTB_I(RA,M,GEO,N,RSI,RTS,DIPS,RES_RS)
USE DB_DATA
IMPLICIT NONE
REAL*8 GET_DTB_I 
INTEGER M,N
REAL*8 RA,GEO,RTS,RSI,DIPS,RES_RS
REAL*8 TEMP0,TEMP1
INTEGER I,J,K
REAL*8 DTBI,RB(5),RAS(4),GES(2)
REAL*8 RS0,RT0
GEO=GEO*1.0
TEMP0=1.0E+12

DO I=1,31
!RS0=0.9*RSI+3.0*(I-1)*RSI/10.0
RS0=0.9*RSI+3.0*(I-1)*RSI/30.0
DO K=1,1 !11
!RT0=0.1*RTS+2.0*(K-1)*RTS/10.0
RT0=RTS
DO J=1,239
DTBI=(j-1)*0.025
CALL AziTrakFM(DIPS,RS0,RT0,DTBI,RB)
RAS(1:4)=RB(1:4)
GES(1)=ABS(RB(5))
TEMP1=(ABS(GES(1))-ABS(GEO))**2.0
IF(TEMP1.LE.TEMP0)THEN
TEMP0=TEMP1
GET_DTB_I=DTBI
ENDIF
ENDDO
ENDDO
ENDDO
END


FUNCTION GET_DTB_I2(RA,M,GEO,N,RTS,DIPS,RES_RS)
USE DB_DATA
IMPLICIT NONE
REAL*8 GET_DTB_I2 
INTEGER M,N
REAL*8 RA,GEO,RTS,DIPS,RES_RS
REAL*8 TEMP0,TEMP1
INTEGER I,J,K
REAL*8 RSI,DTBI,RB(5),RAS(4),GES(2)
GEO=GEO*1.0
TEMP0=1.0E+12
DO I=1,1
!RSI=RES_RS/3.0+2.0*(I-1)*RES_RS/5.0
RSI=RES_RS
DO J=1,121
DTBI=(j-1)*0.05
CALL AziTrakFM(DIPS,RSI,RTS,DTBI,RB)
RAS(1:4)=RB(1:4)
GES(1)=ABS(RB(5))
TEMP1=0.0
TEMP1=(RAS(M)-RA)**2.0+(ABS(GES(1))-ABS(GEO))**2.0
IF(TEMP1.LE.TEMP0)THEN
TEMP0=TEMP1
GET_DTB_I2=DTBI
ENDIF
ENDDO
ENDDO
END



FUNCTION GET_DTB_R(RA,M,RB,N,RTS,DIPS,RES_RS)
USE DB_DATA
IMPLICIT NONE
REAL*8 GET_DTB_R 
INTEGER M,N
REAL*8 RA,RB,RTS,DIPS,RES_RS
REAL*8 TEMP0,TEMP1
INTEGER I,J,K
REAL*8 RSI,DTBI,RAS(5),GES(2)

TEMP0=1.0E+12
DO I=1,1
RSI=RES_RS
DO J=1,121
DTBI=(j-1)*0.05
CALL AziTrakFM(DIPS,RSI,RTS,DTBI,RAS)
TEMP1=0.0
TEMP1=(RAS(M)-RA)**2.0+(RAS(N)-RB)**2.0
IF(TEMP1.LE.TEMP0)THEN
TEMP0=TEMP1
GET_DTB_R=DTBI
ENDIF
ENDDO
ENDDO
END


SUBROUTINE GET_LWD_DATA(LWDFILE,LEN2,RA_LWD,GEO_LWD,GR_ROB,GR,DEP,TVD,MPOINT)
IMPLICIT NONE
INTEGER,INTENT(IN)::LEN2
CHARACTER(LEN=LEN2),INTENT(IN)::LWDFILE
INTEGER,PARAMETER:: M=20000
REAL*8 RA_LWD(M,4),GEO_LWD(M,2),GR_ROB(M,4),GR(M),DEP(M),TVD(M) !存储原始数据
INTEGER MPOINT
INTEGER I,J,K,NPOINT
CHARACTER*15 NAME(200),STR
REAL*8 TEMP
REAL*8,ALLOCATABLE,DIMENSION(:,:)::RA
OPEN(3,FILE=LWDFILE(1:LEN2),STATUS='UNKNOWN')
DO I=1,5
READ(3,*)
ENDDO
READ(3,*)STR,STR,(NAME(J),J=1,200)
CLOSE(3)
DO I=1,200
STR=NAME(I)
IF(STR.EQ.'END')THEN
NPOINT=I
EXIT
ENDIF
ENDDO
OPEN(3,FILE=LWDFILE(1:LEN2),STATUS='UNKNOWN')
DO I=1,7
READ(3,*)
ENDDO
MPOINT=0
DO 
READ(3,*,IOSTAT=I)TEMP
IF(I.NE.0)EXIT
MPOINT=MPOINT+1
ENDDO
CLOSE(3)
NAME=''
ALLOCATE(RA(MPOINT,NPOINT))
OPEN(3,FILE=LWDFILE(1:LEN2),STATUS='UNKNOWN')
DO I=1,4
READ(3,*)
ENDDO 
READ(3,*),STR,STR,NAME(1:NPOINT-1)
READ(3,*)
READ(3,*)
DO I=1,MPOINT
READ(3,*)DEP(I),(RA(I,J),J=1,NPOINT-1)
ENDDO
CLOSE(3)
!曲线名称识别
DO I=1,NPOINT-1
STR=NAME(I)
IF(STR.EQ.'RPCEHM')THEN !高频长源距相位差电阻率 1
RA_LWD(1:MPOINT,1)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'RACEHM')THEN !高频长源距幅度比电阻率 2
RA_LWD(1:MPOINT,2)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'RPCELM')THEN !低频长源距相位差电阻率 5
RA_LWD(1:MPOINT,3)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'RACELM')THEN !低频长源距幅度比电阻率 7
RA_LWD(1:MPOINT,4)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'ARSLLMAXM')THEN  !OK
GEO_LWD(1:MPOINT,1)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'ARSLLTBM')THEN
GEO_LWD(1:MPOINT,2)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'ABDCF01M')THEN
GR_ROB(1:MPOINT,1)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'ABDCF05M')THEN
GR_ROB(1:MPOINT,2)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'ABDCF13M')THEN
GR_ROB(1:MPOINT,3)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'ABDCF09M')THEN
GR_ROB(1:MPOINT,4)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'TVDE'.OR.STR.EQ.'TVD'.OR.STR.EQ.'SSTVD')THEN
TVD(1:MPOINT)=RA(1:MPOINT,I)
ENDIF
IF(STR.EQ.'GR'.OR.STR.EQ.'GRC'.OR.STR.EQ.'GRCFM')THEN
GR(1:MPOINT)=RA(1:MPOINT,I)
ENDIF
ENDDO
DEALLOCATE(RA)
END



SUBROUTINE GET_INITIAL(INIFILE,CZDAT,MPO)
IMPLICIT NONE
CHARACTER(*)INIFILE
INTEGER,PARAMETER:: M=20000
INTEGER MPOINT
REAL*8 CZDAT(M,6)
INTEGER I,J,K,CS,NUM,MPO,LBN
REAL*8,ALLOCATABLE,DIMENSION(:):: DEP,THL,THL1,TVD
REAL*8,ALLOCATABLE,DIMENSION(:,:)::DTB,RTH,RTV
REAL*8,ALLOCATABLE,DIMENSION(:,:)::INITAL
CHARACTER*15 NAME(200),STR
REAL*8 TEMP
OPEN(3,FILE=INIFILE(1:LEN_TRIM(INIFILE)),STATUS='UNKNOWN')
DO I=1,5
READ(3,*)
ENDDO
READ(3,*)STR,STR,(NAME(I),I=1,200)
CLOSE(3)
DO I=1,200
STR=NAME(I)
IF(STR.EQ.'END')THEN
CS=I
EXIT
ENDIF
ENDDO
OPEN(3,FILE=INIFILE(1:LEN_TRIM(INIFILE)),STATUS='UNKNOWN')
DO I=1,7
READ(3,*)
ENDDO
MPOINT=0
DO 
READ(3,*,IOSTAT=I)TEMP
IF(I.NE.0)EXIT
MPOINT=MPOINT+1
ENDDO
CLOSE(3)
ALLOCATE(DEP(MPOINT),THL(MPOINT),THL1(MPOINT),TVD(MPOINT))
ALLOCATE(INITAL(MPOINT,6))
NUM=(CS-3)/3-1
ALLOCATE(DTB(MPOINT,NUM),RTH(MPOINT,NUM+1),RTV(MPOINT,NUM+1))
OPEN(3,FILE=INIFILE(1:LEN_TRIM(INIFILE)),STATUS='UNKNOWN')
DO I=1,7
READ(3,*)
ENDDO
DO I=1,MPOINT
READ(3,*)DEP(I),TVD(I),THL(I),THL1(I),(DTB(I,J),J=1,NUM),(RTH(I,J),J=1,NUM+1),(RTV(I,J),J=1,NUM+1)
ENDDO
CLOSE(3)
DO I=1,MPOINT
IF(DTB(I,1).GE.0.0)THEN
INITAL(I,2)=MIN(DTB(I,1)-6.0,-6.0) !DTBU
INITAL(I,3)=DTB(I,1)               !DTBD
INITAL(I,4)=RTH(I,1)               !RSU
INITAL(I,5)=RTH(I,1)               !RT
INITAL(I,6)=RTH(I,2)               !RSD
ELSEIF(DTB(I,NUM).LE.0.0)THEN
INITAL(I,2)=DTB(I,NUM)             !DTBU
INITAL(I,3)=MAX(DTB(I,1)+6.0,6.0)  !DTBD
INITAL(I,4)=RTH(I,NUM)             !RSU
INITAL(I,5)=RTH(I,NUM+1)           !RT
INITAL(I,6)=RTH(I,NUM+1)           !RSD
ELSE
DO J=1,NUM-1
IF(DTB(I,J).LT.0.0.AND.DTB(I,J+1).GE.0.0)THEN
INITAL(I,2)=DTB(I,J)               !DTBU
INITAL(I,3)=DTB(I,J+1)             !DTBD
INITAL(I,4)=RTH(I,J+0)             !RSU
INITAL(I,5)=RTH(I,J+1)             !RT
INITAL(I,6)=RTH(I,J+2)             !RSD
EXIT
ENDIF
ENDDO
ENDIF
ENDDO
LBN=10
DO I=LBN+1,MPOINT-LBN
TVD(I)=SUM(TVD(I-LBN:I+LBN))/(2.0*LBN+1.0)
DEP(I)=SUM(DEP(I-LBN:I+LBN))/(2.0*LBN+1.0)
ENDDO
DO I=1,MPOINT-1
INITAL(I,1)=ACOS((TVD(I+1)-TVD(I))/(DEP(I+1)-DEP(I)))/ACOS(-1.0)*180.0
ENDDO
INITAL(1:LBN,1)=INITAL(LBN+1,1)
INITAL(MPOINT-LBN:MPOINT,1)=INITAL(MPOINT-LBN-1,1)
!CZDAT(1:6)=INITAL(MPO,1:6) 
DO I=1,MPOINT
CZDAT(I,1:6)=INITAL(I,1:6)
ENDDO

!DO I=1,MPOINT
!CZDAT(I,2)=-0.5
!CZDAT(I,3)=3.5
!CZDAT(I,4)=2.8
!CZDAT(I,5)=83.5
!CZDAT(I,6)=5.0
!ENDDO

DEALLOCATE(DTB,RTH,RTV)
DEALLOCATE(DEP,THL,THL1,TVD)
DEALLOCATE(INITAL)
END

SUBROUTINE INITIAL2CSZ(INIFILE,LENS,CZDAT,MPO)
IMPLICIT NONE
INTEGER LENS
CHARACTER(*)INIFILE
INTEGER,PARAMETER:: M=20000
INTEGER MPOINT
INTEGER I,J,K,CS,NUM,MPO,LBN
REAL*8 CZDAT(MPO,6)
REAL*8,ALLOCATABLE,DIMENSION(:):: DEP,THL,THL1,TVD
REAL*8,ALLOCATABLE,DIMENSION(:,:)::DTB,RTH,RTV
REAL*8,ALLOCATABLE,DIMENSION(:,:)::INITAL
CHARACTER*15 NAME(200),STR
REAL*8 TEMP
OPEN(3,FILE=INIFILE(1:LEN_TRIM(INIFILE)),STATUS='UNKNOWN')
DO I=1,5
READ(3,*)
ENDDO
READ(3,*)STR,STR,(NAME(I),I=1,200)
CLOSE(3)
DO I=1,200
STR=NAME(I)
IF(STR.EQ.'END')THEN
CS=I
EXIT
ENDIF
ENDDO
OPEN(3,FILE=INIFILE(1:LEN_TRIM(INIFILE)),STATUS='UNKNOWN')
DO I=1,7
READ(3,*)
ENDDO
MPOINT=0
DO 
READ(3,*,IOSTAT=I)TEMP
IF(I.NE.0)EXIT
MPOINT=MPOINT+1
ENDDO
CLOSE(3)
MPOINT=MIN(MPO,MPOINT)
ALLOCATE(DEP(MPOINT),THL(MPOINT),THL1(MPOINT),TVD(MPOINT))
ALLOCATE(INITAL(MPOINT,6))
NUM=(CS-3)/2-1
ALLOCATE(DTB(MPOINT,NUM),RTH(MPOINT,NUM+1),RTV(MPOINT,NUM+1))
OPEN(3,FILE=INIFILE(1:LEN_TRIM(INIFILE)),STATUS='UNKNOWN')
DO I=1,7
READ(3,*)
ENDDO
DO I=1,MPOINT
READ(3,*)DEP(I),TVD(I),THL(I),THL1(I),(DTB(I,J),J=1,NUM),(RTH(I,J),J=1,NUM+1) !,(RTV(I,J),J=1,NUM+1)
ENDDO
CLOSE(3)


!上下边界位置确定初值（井眼一侧最多一个边界）
DO I=1,MPOINT
IF(DTB(I,1).GE.0.0)THEN
INITAL(I,2)=MIN(DTB(I,1)-6.0,-6.0) !DTBU
INITAL(I,3)=DTB(I,1)               !DTBD
INITAL(I,4)=RTH(I,1)               !RSU
INITAL(I,5)=RTH(I,1)               !RT
INITAL(I,6)=RTH(I,2)               !RSD
ELSEIF(DTB(I,NUM).LE.0.0)THEN
INITAL(I,2)=DTB(I,NUM)             !DTBU
INITAL(I,3)=MAX(DTB(I,1)+6.0,6.0)  !DTBD
INITAL(I,4)=RTH(I,NUM)             !RSU
INITAL(I,5)=RTH(I,NUM+1)           !RT
INITAL(I,6)=RTH(I,NUM+1)           !RSD
ELSE
DO J=1,NUM-1
IF(DTB(I,J).LT.0.0.AND.DTB(I,J+1).GE.0.0)THEN
INITAL(I,2)=DTB(I,J)               !DTBU
INITAL(I,3)=DTB(I,J+1)             !DTBD
INITAL(I,4)=RTH(I,J+0)             !RSU
INITAL(I,5)=RTH(I,J+1)             !RT
INITAL(I,6)=RTH(I,J+2)             !RSD
EXIT
ENDIF
ENDDO
ENDIF
ENDDO

!边界距离确定三层模型（允许两个边界在井眼一侧）
DO I=1,MPOINT
IF(DTB(I,1).GE.0.0)THEN !所有界面在井眼下方
INITAL(I,2)=DTB(I,1)               !DTBU +
INITAL(I,3)=DTB(I,2)               !DTBD +
INITAL(I,4)=RTH(I,1)               !RSU
INITAL(I,5)=RTH(I,2)               !RT
INITAL(I,6)=RTH(I,3)               !RSD
ELSEIF(DTB(I,NUM).LE.0.0)THEN !所有界面在井眼上方
INITAL(I,2)=DTB(I,NUM-1)             !DTBU -
INITAL(I,3)=DTB(I,NUM)               !DTBD -
INITAL(I,4)=RTH(I,NUM-1)             !RSU
INITAL(I,5)=RTH(I,NUM+0)             !RT
INITAL(I,6)=RTH(I,NUM+1)             !RSD
ELSE
DO J=1,NUM-1
IF(DTB(I,J).LT.0.0.AND.DTB(I,J+1).GE.0.0)THEN  !井眼上下均有层界面
INITAL(I,2)=DTB(I,J)               !DTBU -
INITAL(I,3)=DTB(I,J+1)             !DTBD +
INITAL(I,4)=RTH(I,J+0)             !RSU
INITAL(I,5)=RTH(I,J+1)             !RT
INITAL(I,6)=RTH(I,J+2)             !RSD
    !修正
    IF(J.EQ.1.AND.J+2.LE.NUM)THEN !上面最多只有一个界面
    IF(ABS(DTB(I,J)).GT.ABS(DTB(I,J+2)))THEN
    INITAL(I,2)=DTB(I,J+1)             !DTBU +
    INITAL(I,3)=DTB(I,J+2)             !DTBD +
    INITAL(I,4)=RTH(I,J+1)             !RSU
    INITAL(I,5)=RTH(I,J+2)             !RT
    INITAL(I,6)=RTH(I,J+3)             !RSD
    ENDIF
    ELSEIF(J.EQ.NUM-1.AND.J-1.GE.1)THEN !下面最多只有一个界面
    IF(ABS(DTB(I,J-1)).LT.ABS(DTB(I,J+1)))THEN
    INITAL(I,2)=DTB(I,J-1)               !DTBU -
    INITAL(I,3)=DTB(I,J+0)             !DTBD -
    INITAL(I,4)=RTH(I,J-1)             !RSU
    INITAL(I,5)=RTH(I,J+0)             !RT
    INITAL(I,6)=RTH(I,J+1)             !RSD
    ENDIF
    ELSEIF(J.GE.2.AND.J.LE.NUM-2)THEN !上下均有至少2个界面
    IF(ABS(DTB(I,J-1)).LT.ABS(DTB(I,J+1)))THEN  !最近层界面在井眼上方
    INITAL(I,2)=DTB(I,J-1)               !DTBU -
    INITAL(I,3)=DTB(I,J+0)             !DTBD -
    INITAL(I,4)=RTH(I,J-1)             !RSU
    INITAL(I,5)=RTH(I,J+0)             !RT
    INITAL(I,6)=RTH(I,J+1)             !RSD
    ELSEIF(ABS(DTB(I,J+2)).LT.ABS(DTB(I,J)))THEN !最近层界面在井眼下方
    INITAL(I,2)=DTB(I,J+1)               !DTBU +
    INITAL(I,3)=DTB(I,J+2)             !DTBD +
    INITAL(I,4)=RTH(I,J+1)             !RSU
    INITAL(I,5)=RTH(I,J+2)             !RT
    INITAL(I,6)=RTH(I,J+3)             !RSD
    ENDIF
    ENDIF
EXIT
ENDIF
ENDDO
ENDIF
ENDDO



LBN=10
DO I=LBN+1,MPOINT-LBN
TVD(I)=SUM(TVD(I-LBN:I+LBN))/(2.0*LBN+1.0)
DEP(I)=SUM(DEP(I-LBN:I+LBN))/(2.0*LBN+1.0)
ENDDO
DO I=1,MPOINT-1
INITAL(I,1)=ACOS((TVD(I+1)-TVD(I))/(DEP(I+1)-DEP(I)))/ACOS(-1.0)*180.0
ENDDO
INITAL(1:LBN,1)=INITAL(LBN+1,1)
INITAL(MPOINT-LBN:MPOINT,1)=INITAL(MPOINT-LBN-1,1)
!CZDAT(1:6)=INITAL(MPO,1:6) 
DO I=1,MPOINT
CZDAT(I,1:6)=INITAL(I,1:6)
ENDDO

!DO J=5,5
!DO I=51,MPOINT-50
!CZDAT(I,J)=SUM(INITAL(I-50:I+50,J))/101.0
!ENDDO
!ENDDO
!DO I=1,MPOINT
!IF(CZDAT(I,2).LT.0.0.AND.CZDAT(I,3).GT.0.0.AND.MIN(ABS(CZDAT(I,3)),ABS(CZDAT(I,2))).GT.2.5)THEN
!CZDAT(I,4)=0.5*INITAL(I,4)+INITAL(I,6)*0.50
!CZDAT(I,6)=0.5*INITAL(I,4)+INITAL(I,6)*0.50
!ENDIF
!ENDDO

OPEN(301,FILE="CSZ0211.TXT",STATUS='UNKNOWN')
WRITE(301,"(A30)")"WN	=	wellname.gud"
WRITE(301,"(A15,F20.6)")"STDEP	= ",DEP(1)	
WRITE(301,"(A15,F20.6)")"ENDEP	= ",DEP(MPOINT)	
WRITE(301,"(A15,F20.6)")"RLEV	= ",DEP(2)-DEP(1)
WRITE(301,"(20A15)")"CURVENAME	= ", " CTVD ", " CTHL "	, " CTHL1 "	, " CDTB1 "	, " CDTB2 "	, " CRTH1 "	, " CRTH2 "	, " CRTH3 "	
WRITE(301,"(20A15)")"CURVEUNIT	= ",  " M ", " M "	, " M "	, " M "	, " M "	, " OHMM "	, " OHMM "	, " OHMM "		
WRITE(301,"(A30)")"END"			
DO I=1,MPOINT
WRITE(301,"(20F20.6)")DEP(I),TVD(I),THL(I),THL1(I),CZDAT(I,2:6)
ENDDO
CLOSE(301)

DEALLOCATE(DTB,RTH,RTV)
DEALLOCATE(DEP,THL,THL1,TVD)
DEALLOCATE(INITAL)
END





    SUBROUTINE INV_AziTrack1(APPARENTRT,INITAL_VAR,RES_VAR)
    USE SHARE_PRECISION2
    IMPLICIT NONE
!    CHARACTER*(*)DBPATH
    INTEGER, PARAMETER :: NN_AZI = 4, TRN=4,  MAXITM=16,CST=4
    INTEGER, PARAMETER :: CVS=4   !反回结果未知量个数
    INTEGER, PARAMETER :: M = 5   ! THE NUMBER OF CURVE曲线条数
    INTEGER, PARAMETER :: N_VAR = 4   !变量改变步长未知变量个数
    REAL(KIND = DBL) :: INITAL_VAR(CVS), APPARENTRT(M), RES_VAR(CVS)
    INTEGER :: I, J, JJ, MPOINT, NPOINT
    REAL(KIND = DBL), ALLOCATABLE, DIMENSION(:) :: DEPT, DEP, RM, RH, TVD, HOR, CHL
    REAL(KIND = DBL), ALLOCATABLE, DIMENSION(:) :: DTBU, DTBD, DIP, RSU, RTH, RSD
    INTEGER :: I_MP, N_ITE, I_VAR
    INTEGER :: FRE,flag
    REAL(KIND = DBL) :: RT_H_S, RT_V_S, DIS_ECC_S, FAI_E_S
    REAL(KIND = DBL), DIMENSION(N_VAR) :: X_VAR, X_VAR_OPT, YS_VAR
    REAL(KIND = DBL), DIMENSION(M) :: D_VALUE, D_VALUE_1, D_VALUE_2
    REAL(KIND = DBL), EXTERNAL :: COST
    REAL(KIND = DBL) :: VARIANCE, SA, SB, HF, HZ, DETA, UU
    REAL(KIND = DBL), DIMENSION(N_VAR) :: H, DX_VAR, FF
    REAL(KIND = DBL), DIMENSION(M,N_VAR) :: DF
    REAL(KIND = DBL), DIMENSION(M) :: RPSRAD
    REAL(KIND = DBL), DIMENSION(N_VAR,N_VAR) :: DDF
    REAL*8 TEEM

    MPOINT=1
    ALLOCATE(DEPT(MPOINT), RM(MPOINT), RH(MPOINT), DEP(MPOINT), TVD(MPOINT), HOR(MPOINT), CHL(MPOINT))
    ALLOCATE(DTBU(MPOINT), DTBD(MPOINT), DIP(MPOINT), RSU(MPOINT), RTH(MPOINT), RSD(MPOINT))
    DTBU=0.0
    DTBD=0.0
    DIP=0.0
    RSU=0.0
    RTH=0.0
    RSD=0.0
    LOOP_MPOINT:DO I_MP = 1, MPOINT  !单点计算
        DO I=1,N_VAR
        X_VAR(I) = INITAL_VAR(I)
        YS_VAR(I) = X_VAR(I)    !初值作为约束条件      
        ENDDO
        RPSRAD(1:M)=APPARENTRT(1:M) !测量电阻率赋值
        DO I_VAR = 1, N_VAR 
            H(I_VAR) = 0.001_DBL !求雅克比矩阵时未知量改变量
        ENDDO
        X_VAR_OPT = X_VAR
        CALL FUNCT( X_VAR, D_VALUE, RPSRAD,YS_VAR) !正演模拟
        SA = COST(D_VALUE, M) !计算初始模型残差和
        SB = SA
        N_ITE = 0
        LOOP_ITE:DO
            N_ITE = N_ITE + 1 !记录迭代次数
            IF(N_ITE > MAXITM .OR. SA < 1.0D-03) EXIT LOOP_ITE !循环终止条件：迭代次数超过300 或者 误差足够小
            LOOP_VAR:DO I_VAR = 1, N_VAR !根据模型增量 det-X 计算 det-Y
                HF = H(I_VAR)
                HZ = X_VAR(I_VAR)
                X_VAR(I_VAR) = HZ + HF
                CALL FUNCT( X_VAR, D_VALUE_1, RPSRAD,YS_VAR)
                X_VAR(I_VAR) = HZ - HF
                CALL FUNCT( X_VAR, D_VALUE_2, RPSRAD,YS_VAR)
                X_VAR(I_VAR) = HZ
                HZ = 0.5_DBL/HF   
                DO I = 1, M
                    DF(I,I_VAR) = (D_VALUE_1(I) - D_VALUE_2(I))*HZ !计算差分，代替微分
                ENDDO
            ENDDO LOOP_VAR
            DDF = 0.0_DBL
            FF = 0.0_DBL
            DO I = 1, N_VAR !计算雅克比矩阵
                DO J = 1, N_VAR !N_VAR变量个数
                    DO JJ = 1, M !曲线个数
                        DDF(I,J) = DDF(I,J) + DF(JJ,I)*DF(JJ,J)
                    ENDDO
                ENDDO
                DO JJ = 1, M
                    FF(I) = FF(I) + DF(JJ,I) * D_VALUE(JJ)
                ENDDO
            ENDDO

    !如果DDF不满秩
    DETA=0.0
    UU=5.0
    DO
    CALL BSDET(DDF,N_VAR,DETA)
    IF(ABS(DETA).GE.1E-4)EXIT
    DO I=1, N_VAR
    DO J=1, N_VAR
    IF(ABS(DDF(I,J)).LT.1E-6)DDF(I,J)=0.0
    ENDDO
    ENDDO
    DO I = 1, N_VAR !不满秩矩阵处理
        IF(DDF(I,I).LE.1E-4)THEN
        DDF(I,I)=1.0
        FF(I)=0.0
        ENDIF
    ENDDO
    CALL BSDET(DDF,N_VAR,DETA)
    IF(ABS(DETA).LE.1E-4)THEN
        DO I=1,N_VAR
        DDF(I,I)=DDF(I,I)+UU
        ENDDO
    ENDIF    
    ENDDO
            X_VAR_OPT = X_VAR
            CALL GINV(DDF,FF,DX_VAR,N_VAR) !解方程，计算最速下降方向
            IF(ISNAN(SUM(DX_VAR(1:N_VAR))))DX_VAR=0.0
            DO I_VAR = 1, N_VAR  !根据增量修改模型
                IF(ABS(DX_VAR(I_VAR)).GT.1.0)DX_VAR(I_VAR)=DX_VAR(I_VAR)/ABS(DX_VAR(I_VAR)) !控制步长改变量
                X_VAR(I_VAR) = X_VAR(I_VAR) - DX_VAR(I_VAR)
            ENDDO
            IF(SUM(ABS(DX_VAR)) <= 1.0D-04) EXIT LOOP_ITE !模型增量足够小，模型不在改变，终止迭代
            
            !添加约束
            IF(ABS(X_VAR(1)-90.0).GE.30.0)THEN   !倾角约束
               X_VAR(1)=YS_VAR(1)
            ELSEIF(X_VAR(1)-YS_VAR(1).GT.15.0)THEN
               X_VAR(1)=YS_VAR(1)+15.0
            ELSEIF(X_VAR(1)-YS_VAR(1).LT.-15.0)THEN
               X_VAR(1)=YS_VAR(1)-15.0
            ENDIF

            IF(X_VAR(2).GE.500.0)THEN   !RS约束
               X_VAR(2)=500.0
            ELSEIF(X_VAR(2).LE.0.5)THEN   !RS约束
               X_VAR(2)=0.5
            ELSEIF(X_VAR(2).GE.30.0+YS_VAR(2))THEN
               X_VAR(2)=30.0+YS_VAR(2)
            ELSEIF(X_VAR(2).GE.-30+YS_VAR(2))THEN
               X_VAR(2)=-30+YS_VAR(2)
            ENDIF            

            IF(X_VAR(3).GE.500.0)THEN   !RT约束
               X_VAR(3)=500.0
            ELSEIF(X_VAR(3).LE.0.5)THEN   !RT约束
               X_VAR(3)=0.5
            ELSEIF(X_VAR(3).GE.50.0+YS_VAR(3))THEN
               X_VAR(3)=50.0+YS_VAR(3)
            ELSEIF(X_VAR(3).GE.-50+YS_VAR(3))THEN
               X_VAR(3)=-50+YS_VAR(3)
            ENDIF

            IF(ABS(X_VAR(1)-0.0).GT.6.0)THEN   !边界距离约束
               X_VAR(1)=YS_VAR(1)
            ELSEIF(X_VAR(1)-YS_VAR(1).GT.6.0)THEN
               X_VAR(1)=YS_VAR(1)+6.0
            ELSEIF(X_VAR(1)-YS_VAR(1).LT.-6.0)THEN
               X_VAR(1)=YS_VAR(1)-6.0
            ENDIF

              
            CALL FUNCT( X_VAR, D_VALUE, RPSRAD,YS_VAR) !计算新模型残差
            SB = COST(D_VALUE, M)            
            IF(SB <= SA) X_VAR_OPT = X_VAR !误差若下降，保留最新模型            
            IF(ABS(SB-SA) > 1.0D-04*SA .AND. SUM(ABS(DX_VAR(1:N_VAR))) > 1.0D-04)THEN !根据误差增量判断是否终止迭代
                SA = SB
            ELSE
                EXIT LOOP_ITE
            ENDIF
        ENDDO LOOP_ITE      
        RES_VAR(1:CVS)=X_VAR_OPT(1:CVS) 
!if(X_VAR_OPT(CVS).eq.0.0)then
!print*,X_VAR_OPT(CVS)
!endif
    !DTBU(I_MP) = X_VAR_OPT(1)   !上边界距离
    !DTBD(I_MP) = X_VAR_OPT(2)   !下边界距离
    !DIP(I_MP) = X_VAR_OPT(3)    !倾角
    !RSU(I_MP) = X_VAR_OPT(4)    !上围岩电阻率
    !RTH(I_MP) = X_VAR_OPT(5)    !目的层电阻率
    !RSD(I_MP) =  X_VAR_OPT(6)   !下围岩电阻率        
    ENDDO LOOP_MPOINT           
    !OPEN(51, FILE = FILENAME3(1:LEN_TRIM(FILENAME3)), STATUS = 'UNKNOWN')
    !WRITE(51,"(300A20)")"DEPTH","TVD","HOR","CHL","DTBU","DTBD","DIP","RSU","RTH","RSD"
    !DO I=1,MPOINT
    !WRITE(51,'(1F15.5,200F20.8)')DEP(I), TVD(I), HOR(I), CHL(I), DTBU(I), DTBD(I), DIP(I), RSU(I), RTH(I), RSD(I)  !输出反演结果        
    !ENDDO
    !CLOSE(51)        
    DEALLOCATE(DEPT, RM, RH, DEP, TVD, HOR, CHL)
    DEALLOCATE(DTBU, DTBD, DIP, RSU, RTH, RSD)
    END  
    
    SUBROUTINE FUNCT( X_VAR, D_VALUE, YRES_P,YS_VAR)
    USE SHARE_PRECISION2
    IMPLICIT NONE
!    CHARACTER*(*)DBPATH
    INTEGER, PARAMETER :: NN_AZI = 5  !曲线条数
    INTEGER, PARAMETER :: N_VAR = 4   !未知变量个数
    INTEGER FRE
    REAL(KIND = DBL), INTENT(IN), DIMENSION(N_VAR) :: X_VAR,YS_VAR
    REAL(KIND = DBL), INTENT(IN), DIMENSION(NN_AZI) :: YRES_P
    REAL(KIND = DBL), INTENT(OUT), DIMENSION(NN_AZI) :: D_VALUE
    REAL(KIND = DBL), DIMENSION(N_VAR) :: XX_VAR
    REAL(KIND = DBL), DIMENSION(NN_AZI) :: SRES_ARS, SRES_PHS
    REAL*8 TEEM
    INTEGER :: I_AZI    
    FRE=1
    XX_VAR(:) = X_VAR(:)
    
    CALL AziTrakFM(XX_VAR(1),XX_VAR(2),XX_VAR(3),XX_VAR(4),SRES_PHS)
    D_VALUE = 0.0_DBL
    DO I_AZI = 1, NN_AZI-1
        IF(YRES_P(I_AZI).LE.500.0.AND.YRES_P(I_AZI).GE.0.2)THEN
        D_VALUE(I_AZI) = SRES_PHS(I_AZI)-YRES_P(I_AZI) !测量值大于某一个值，不参与计算残差
        ELSE
        D_VALUE(I_AZI) = 0.0
        ENDIF
        D_VALUE(5) = SRES_PHS(5)-YRES_P(5)
    ENDDO
    END SUBROUTINE FUNCT
    
    FUNCTION COST(F,M)
    USE SHARE_PRECISION2
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: M
    REAL(KIND = DBL), INTENT(IN), DIMENSION(M) :: F
    REAL(KIND = DBL) :: COST
    INTEGER :: I    
    COST=0.0_DBL
    DO I=1,M
    COST=COST+F(I)*F(I)
    ENDDO    
    END FUNCTION COST

    !线性最小二乘方的问题
    SUBROUTINE GINV(A,B,Y,N)
    !B-曲线差(f(x)-f(x0));Y-DX-步长;M-采样点的个数;N-待反演未知数的个数;IEQVAT=1;TOL=EPS3；A为Jocabbi矩阵
    USE SHARE_PRECISION2
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N
    REAL(KIND = DBL), INTENT(INOUT), DIMENSION(N,N) :: A
    REAL(KIND = DBL), INTENT(INOUT), DIMENSION(N) :: B
    REAL(KIND = DBL), INTENT(OUT), DIMENSION(N) :: Y
    INTEGER :: I, J, K, JM1
    REAL(KIND = DBL), DIMENSION(:) :: AINDEX(300), WORK(300), X(100,100)
    REAL(KIND = DBL) :: ANORM, REM, FAC
    DO 15 I=1,N
    DO 10 J=I+1,N
    X(I,J)=0.0_DBL
10  CONTINUE
    X(I,I)=1.0_DBL
15  CONTINUE
    DO 85 J=1,N
    CALL PRODUCT(A,ANORM,J,J,N)   !返回ANORM
    JM1=J-1
    DO 20 K=1,JM1
    CALL PRODUCT(A,WORK(K),J,K,N)  !返回WORK(K)表示矩阵A的第k列与第j列的内积
20  CONTINUE    
    DO 30 I=1,N   
    DO 25 K=1,JM1
    A(I,J)=A(I,J)-A(I,K)*AINDEX(K)*WORK(K)
25  CONTINUE
30  CONTINUE
    DO 40 I=1,JM1
    DO 35 K=1,JM1
    X(I,J)=X(I,J)-X(I,K)*WORK(K)  !求上三角矩阵的逆不带对角线上的元素
35  CONTINUE
40  CONTINUE
    CALL PRODUCT(A,REM,J,J,N)   !返回REM,其值表示正交后的	  
    AINDEX(J)=1.0_DBL
    FAC=1.0_DBL/SQRT(REM)
    DO 75 I=1,N   
    A(I,J)=A(I,J)*FAC
75  CONTINUE
    DO 80 I=1,J
    X(I,J)=X(I,J)*FAC  !求上三角矩阵的逆带对角线上的元素
80  CONTINUE
85  CONTINUE
    !其中X表示上三角矩阵R的逆矩阵，A矩阵表示正交矩阵Q，work表示TRANSPOSE（Q）*B
    DO 110 I=1,N
    FAC=0.0_DBL
    DO 105 J=1,N   
    FAC=FAC+B(J)*A(J,I)
105 CONTINUE
    WORK(I)=FAC
110 CONTINUE
    DO 120 I=1,N
    FAC=0.0_DBL
    DO 115 J=I,N
    FAC=FAC+X(I,J)*WORK(J)
115 CONTINUE
    Y(I)=FAC
120 CONTINUE
    CLOSE(19)
	RETURN
	END

    SUBROUTINE GINV2(A,B,Y,M,N)
    !B-曲线差(f(x)-f(x0));Y-DX-步长;M-采样点的个数;N-待反演未知数的个数;IEQVAT=1;TOL=EPS3；A为Jocabbi矩阵
    USE SHARE_PRECISION2
    IMPLICIT DOUBLE PRECISION (A-H)
    IMPLICIT DOUBLE PRECISION (O-Z)
    REAL(KIND = DBL) A(N,N),B(N),Y(N)
    REAL(KIND = DBL) AINDEX(300),WORK(300),X(100,100)
    REAL(KIND = DBL) ANORM,REM
    DO 15 I=1,N
    DO 10 J=I+1,N
    X(I,J)=0.
10  CONTINUE
    X(I,I)=1.
15  CONTINUE
    DO 85 J=1,N
    CALL PRODUCT2(A,ANORM,J,J,M,N)   !返回ANORM
    JM1=J-1
    DO 20 K=1,JM1
    CALL PRODUCT2(A,WORK(K),J,K,M,N)  !返回WORK(K)表示矩阵A的第k列与第j列的内积
20  CONTINUE    
    DO 30 I=1,N   
    DO 25 K=1,JM1
    A(I,J)=A(I,J)-A(I,K)*AINDEX(K)*WORK(K)
25  CONTINUE
30  CONTINUE
    DO 40 I=1,JM1
    DO 35 K=1,JM1
    X(I,J)=X(I,J)-X(I,K)*WORK(K)  !求上三角矩阵的逆不带对角线上的元素
35  CONTINUE
40  CONTINUE
    CALL PRODUCT2(A,REM,J,J,M,N)   !返回REM,其值表示正交后的	  
    AINDEX(J)=1.0
    FAC=1./SQRT(REM)
    DO 75 I=1,N   
    A(I,J)=A(I,J)*FAC
75  CONTINUE
    DO 80 I=1,J
    X(I,J)=X(I,J)*FAC  !求上三角矩阵的逆带对角线上的元素
80  CONTINUE
85  CONTINUE
    !其中X表示上三角矩阵R的逆矩阵，A矩阵表示正交矩阵Q，work表示TRANSPOSE（Q）*B
    DO 110 I=1,N
    FAC=0.
    DO 105 J=1,N   
    FAC=FAC+B(J)*A(J,I)
105 CONTINUE
    WORK(I)=FAC
110 CONTINUE
    DO 120 I=1,N
    FAC=0.
    DO 115 J=I,N
    FAC=FAC+X(I,J)*WORK(J)
115 CONTINUE
    Y(I)=FAC
120 CONTINUE
    CLOSE(19)
	RETURN
	END

    !处理内积
    SUBROUTINE PRODUCT(A,AMUL,J1,J2,N)
    USE SHARE_PRECISION2
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: J1, J2, N
    REAL(KIND = DBL), INTENT(IN), DIMENSION(N,N) :: A
    REAL(KIND = DBL), INTENT(OUT) :: AMUL
    INTEGER :: I    
    AMUL=0.0_DBL
    DO I=1,N   
        AMUL=AMUL+A(I,J1)*A(I,J2)
    ENDDO    
	RETURN
	END
    
    SUBROUTINE PRODUCT2(A,AMUL,J1,J2,M,N)
    USE SHARE_PRECISION2
    IMPLICIT DOUBLE PRECISION (A-H)
    IMPLICIT DOUBLE PRECISION (O-Z)
    REAL(KIND = DBL) A(N,N)
    REAL(KIND = DBL) AMUL
    AMUL=0.0
    DO 10 I=1,N   
    AMUL=AMUL+A(I,J1)*A(I,J2)
10  CONTINUE
	RETURN
	END
    
    
    !计算矩阵行列式
    SUBROUTINE BSDET(B,N,DET)
    DIMENSION B(N,N)
    DIMENSION A(N,N)
    DOUBLE PRECISION A,B,DET,F,D,Q
    
    A=B
    F=1.0
    DET=1.0
    DO 100 K=1,N-1
    Q=0.0
    DO 10 I=K,N
    DO 10 J=K,N
    IF (ABS(A(I,J)).GT.Q) THEN
    Q=ABS(A(I,J))
    IS=I
    JS=J
    END IF
10	CONTINUE
    IF (Q+1.0.EQ.1.0) THEN
    DET=0.0
    RETURN
    END IF
    IF (IS.NE.K) THEN
    F=-F
    DO 20 J=K,N
    D=A(K,J)
    A(K,J)=A(IS,J)
    A(IS,J)=D
20	CONTINUE
    END IF
    IF (JS.NE.K) THEN
    F=-F
    DO 30 I=K,N
    D=A(I,JS)
    A(I,JS)=A(I,K)
    A(I,K)=D
30	CONTINUE
    END IF
    DET=DET*A(K,K)
    DO 50 I=K+1,N
    D=A(I,K)/A(K,K)
    DO 40 J=K+1,N
40	A(I,J)=A(I,J)-D*A(K,J)
50	CONTINUE
100	CONTINUE
    DET=F*DET*A(N,N)
    RETURN
    END    



